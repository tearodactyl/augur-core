# Copyright (C) 2015 Forecast Foundation OU, full GPL notice in LICENSE

extern controller: [lookup:[int256]:int256, assertIsWhitelisted:[int256]:int256]

REPORTING = self.controller.lookup('reporting')
extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256,int256,int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOfReporter:[int256,int256]:int256, claimInitialRepFromRepContract:[]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReportedOnNonFinalRoundTwoEvent:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, repIDToIndex:[int256,int256]:int256, setController:[address]:int256, setInitialReporters:[int256]:int256, setRep:[int256,int256,int256]:int256, setReportedOnNonFinalRoundTwoEvent:[int256,int256,int256]:int256, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, suicideFunds:[address]:_, totalSupply:[int256]:int256]

BRANCHES = self.controller.lookup('branches')
extern branches: [addCurrency:[int256,int256,int256,int256]:int256, addMarketToBranch:[int256,int256]:int256, disableCurrency:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranchCurrency:[int256,int256]:int256, getBranchWallet:[int256,int256]:int256, getBranches:[]:int256[], getBranchesStartingAt:[int256]:int256[], getCreationDate:[int256]:int256, getCurrencyActive:[int256,int256]:int256, getCurrencyByContract:[int256,int256]:int256, getCurrencyRate:[int256,int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getForkTime:[int256]:int256, getInitialBalance:[int256,int256,int256]:int256, getMarketIDsInBranch:[int256,int256,int256]:int256[], getMinTradingFee:[int256]:int256, getMostRecentChild:[int256]:int256, getNumBranches:[]:int256, getNumCurrencies:[int256]:int256, getNumMarketsBranch:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256,int256]:int256, reactivateCurrency:[int256,int256]:int256, removeLastCurrency:[int256]:int256, replaceCurrency:[int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setController:[address]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256,int256]:int256, setMostRecentChild:[int256,int256]:int256, suicideFunds:[address]:_, updateCurrencyRate:[int256,int256,int256,int256]:int256, updateNumCurrencies:[int256,int256]:int256]

EXPEVENTS = self.controller.lookup('expiringEvents')
extern expiringEvents: [addEvent:[int256,int256,int256,int256,int256,int256,int256]:int256, addReportToReportsSubmitted:[int256,int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodFeeValue:[int256,int256,int256]:int256, countReportAsSubmitted:[int256,int256,int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getActiveReporters:[int256,int256,int256,int256]:int256[], getAfterFork:[int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256,int256]:int256, getEventWeight:[int256,int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getFeeValue:[int256,int256]:int256, getLesserReportNum:[int256,int256,int256]:int256, getNumActiveReporters:[int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsSubmitted:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepWeight:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getRequired:[int256,int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256,int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setController:[address]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setEventWeight:[int256,int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepWeight:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, suicideFunds:[address]:_]

EVENTS = self.controller.lookup('events')
extern events: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, addReportersPaidSoFar:[int256]:int256, getBond:[int256]:int256, getChallenged:[int256]:int256, getCreationTime:[int256]:int256, getEarlyResolutionBond:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getEventPushedUp:[int256]:int256, getEventResolution:[int256]:bytes, getExpiration:[int256]:int256, getExtraBond:[int256]:int256, getExtraBondPoster:[int256]:int256, getFirstPreliminaryOutcome:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForkResolveAddress:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getMode:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportersPaidSoFar:[int256]:int256, getReportingThreshold:[int256]:int256, getResolutionAddress:[int256]:int256, getResolutionLength:[int256]:int256, getResolveBondPoster:[int256]:int256, getUncaughtOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setChallenged:[int256]:int256, setController:[address]:int256, setCreationTime:[int256]:int256, setEarlyResolutionBond:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setExtraBond:[int256,int256]:int256, setExtraBondPoster:[int256,int256]:int256, setFirstPreliminaryOutcome:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setMode:[int256,int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, suicideFunds:[address]:_]

BACKSTOPS = self.controller.lookup('backstops')
extern backstops: [adjForkBondPaid:[int256,int256]:int256, doRoundTwoRefund:[int256,int256]:int256, getBondAmount:[int256]:int256, getBondPaid:[int256]:int256, getBondPoster:[int256]:int256, getBondReturned:[int256]:int256, getDisputedOverEthics:[int256]:int256, getFinal:[int256]:int256, getForkBondPaid:[int256]:int256, getForkBondPoster:[int256]:int256, getForkedOverEthicality:[int256]:int256, getMoved:[int256]:int256, getOriginalBranch:[int256]:int256, getOriginalEthicality:[int256]:int256, getOriginalOutcome:[int256]:int256, getOriginalVotePeriod:[int256]:int256, getResolved:[int256,int256]:int256, getRoundTwo:[int256]:int256, increaseBondPaid:[int256,int256]:int256, setBondAmount:[int256,int256]:int256, setBondPoster:[int256,int256]:int256, setBondReturned:[int256]:int256, setController:[address]:int256, setDisputedOverEthics:[int256]:int256, setFinal:[int256]:int256, setForkBondPoster:[int256,int256]:int256, setForkedOverEthicality:[int256]:int256, setMoved:[int256]:int256, setOriginalBranch:[int256,int256]:int256, setOriginalEthicality:[int256,int256]:int256, setOriginalOutcome:[int256,int256]:int256, setOriginalVotePeriod:[int256,int256]:int256, setResolved:[int256,int256,int256]:int256, setRoundTwo:[int256,int256]:int256, setRoundTwoRefund:[int256,int256]:int256, suicideFunds:[address]:_]

CLOSEMARKET = self.controller.lookup('closeMarket')
extern closeMarket: [closeChallengeBond:[int256]:int256, closeMarket:[int256,int256]:_, setController:[address]:int256, suicideFunds:[address]:_]

CONSENSUS = self.controller.lookup('consensusData')
extern consensusData: [decreaseDenominator:[int256,int256,int256]:int256, doRefund:[int256,int256]:int256, getBaseReportersLastPeriod:[int256]:int256, getDenominator:[int256,int256]:int256, getFeeFirst:[int256,int256]:int256, getFeesCollected:[int256,int256,int256,int256]:int256, getNotEnoughPenalized:[int256,int256,int256]:int256, getPenalized:[int256,int256,int256,int256]:int256, getPenalizedNum:[int256,int256,int256]:int256, getPenalizedUpTo:[int256,int256]:int256, getPeriodBalance:[int256,int256]:int256, getRepCollected:[int256,int256,int256]:int256, getRepRedistributionDone:[int256,int256]:int256, getSlashed:[int256,int256,int256]:int256, increaseDenominator:[int256,int256,int256]:int256, increasePenalizedNum:[int256,int256,int256,int256]:int256, setBaseReportersLastPeriod:[int256,int256]:int256, setController:[address]:int256, setFeeFirst:[int256,int256,int256]:int256, setFeesCollected:[int256,int256,int256,int256]:int256, setNotEnoughPenalized:[int256,int256,int256]:int256, setPenalized:[int256,int256,int256,int256]:int256, setPenalizedUpTo:[int256,int256,int256]:int256, setPeriodBalance:[int256,int256,int256]:int256, setRefund:[int256,int256]:int256, setRepCollected:[int256,int256,int256]:int256, setSlashed:[int256,int256,int256]:int256, suicideFunds:[address]:_]

MUTEX = self.controller.lookup('mutex')
extern mutex: [acquire:[]:int256, release:[]:int256, setController:[address]:int256, suicideFunds:[address]:_]

REPCHANGELIBRARY = self.controller.lookup('repChangeLib')
extern repChangeLib: [calculateRepChange:[int256,int256,int256,int256,int256,int256,int256]:int256, setController:[address]:int256, suicideFunds:[address]:_]

inset('../macros/refund.sem')
inset('../macros/eventHelpers.sem')
inset('../macros/redistributeRep.sem')
inset('../macros/proportionCorrect.sem')
inset('../macros/repChange.sem')
inset('../macros/float.sem')
inset('../macros/logReturn.sem')
inset('../macros/periodStage.sem')

data controller

event penalize(user:indexed, outcome, oldrep, repchange, newafterrep, p, reportValue)
event consensusLogReturn(returnValue)

macro POINT_ZERO_ONE: 10000000000000000
macro POINT_ONE: 100000000000000000
macro FIVE_PERCENT: 50000000000000000

### Handles the default consensus cases: redistributions during reporting on the first round and incrementing the branch's period

# Penalizes a reporter for reporting wrongly on an event
    # examples from the start of a new branch:
        # ex:
            # period 0 voteperiod -1 - last period penalized should be -1 or starting vote period
            # add some events to period 0
            # increment
            # period 1 voteperiod 0 - shouldn't be penalizing anything yet b/c still reporting on period 0
            # increment
            # period 2 voteperiod 1 - penalize on events in voteperiod 0
        # ex 2:
            # currently in period 100, voteperiod 99 - last period penalized up to should be 99 or starting vote period
            # add some events to period 100
            # increment to period 101
            # period 101, voteperiod 100 - shouldn't be penalizing anything yet
            # increment
            # period 102, voteperiod 101 - penalize on events in voteperiod 100
# 1. Record rep at start of report period [before rep in make reports]
# 2. Penalize for each event
# 3. Each reporter needs to do this for all events they reported on, if not get docked
# 4. For first half of the new period, people can do penalization for the last period, for the second half users have to claim rep then trading fees
# 5. If a reporter doesn't do it for all events, they autolose 10% rep each period one doesn't do it (b/c they're trying to cheat)
# Errors:
    #  0: user has <1 rep
    # -1: need to penalize in round 2 penalize function
    # -2: already past first half of new period and needed to penalize before then / too late to penalize
    # -3: already done for all events in this period
    # -4: forked events should be penalized using the fork penalization function
    # -5: no outcome
    # -6: needed to collect fees last period [but didn't] which sets the before/after rep so now have to call penalizationCatchup
    # -7: invalid branch
# force event to be resolved first if it can be
# call with branch and 0 for the event if no events in a given period [otherwise user won't be "penalized up to" for this period]
def init():
    self.controller = 0x0

def penalizeWrong(branch, event):
    refund()
    MUTEX.acquire()

    repBalance = REPORTING.getRepBalance(branch, msg.sender)
    currentVotePeriod = BRANCHES.getVotePeriod(branch)
    lastPeriod = currentVotePeriod - 1
    periodLength = BRANCHES.getPeriodLength(branch)
    newRep = 0
    rejected = EVENTS.getRejected(event)
    newAfterRep = EXPEVENTS.getAfterRep(branch, lastPeriod, msg.sender)
    oldRep = EXPEVENTS.getBeforeRep(branch, lastPeriod, msg.sender)
    roundTwo = BACKSTOPS.getRoundTwo(event)
    uncaught = EVENTS.getUncaughtOutcome(event)
    outcome = catch(uncaught)
    if(scalar(event) or categorical(event)):
        outcome = uncaught
    checkPenalizeWrongPreconditions()

    repChange = 0
    reportValue = EXPEVENTS.getReport(branch, lastPeriod, event, msg.sender)
    numReportedOn = EXPEVENTS.getNumReportsSubmitted(branch, lastPeriod, msg.sender)
    penalizedOnEvent = CONSENSUS.getPenalized(branch, lastPeriod, msg.sender, event)
    if(eventCreatedPriorToFork(event) and !penalizedOnEvent and reportValue):
        countAsPenalized()
    # lastperiod is where people who originally voted on a round 2 event voted the first time - want num events penalized to go up but not to actually be penalized for it yet
        # shouldn't be penalized until the next period resolution is over [since it's a round 2 event]
    if(roundTwo and !penalizedOnEvent and reportValue):
        countAsPenalized()
        REPORTING.setReportedOnNonFinalRoundTwoEvent(branch, event, msg.sender)
        # count it again if user reported on it the first time as in the next period the user will be penalized for this if they reported incorrectly
        EXPEVENTS.addReportToReportsSubmitted(branch, currentVotePeriod, msg.sender)
    # if this event was a pushed forward event that got rejected, don't penalize on it, only penalize on the final reporting, i.e. don't allow rep redistribution until the original period it was supposed to resolve in
    elif(!penalizedOnEvent and reportValue and rejected and EVENTS.getRejectedPeriod(event) == lastPeriod):
        countAsPenalized()
    # penalization on a regular event if not already penalized, it has outcome, and user reported on it
    elif(!penalizedOnEvent and reportValue and outcome != 0):
        # .25% per event / 2.5% max
        repChange = REPCHANGELIBRARY.calculateRepChange(reportValue, POINT_ONE / 4, oldRep, p, event, outcome, numReportedOn, call = delegate)
        updateAfterRep()
        countAsPenalized()
        log(type = penalize, msg.sender, outcome, oldRep, repChange, newAfterRep, p, reportValue)
    # once penalized for all events actually get rid of net rep lost and send it to the branch for redistribution
    if(numReportedOn == CONSENSUS.getPenalizedNum(branch, lastPeriod, msg.sender)):
        sendRedistributedRepToBranch()
    MUTEX.release()
    logReturn(consensusLogReturn, 1)

macro checkPenalizeWrongPreconditions():
    if(EVENTS.getEventBranch(event) != branch):
        MUTEX.release()
        logReturn(consensusLogReturn, -7)
    if(repBalance < ONE):
        MUTEX.release()
        logReturn(consensusLogReturn, 0)
    p = proportionCorrect(event, 0)
    if(roundTwo and outcome != 0):
        MUTEX.release()
        logReturn(consensusLogReturn, -1)
    atFirstHalfOfPeriod()
    tooLateToPenalize = (block.timestamp / periodLength - 2) != lastPeriod
    if(tooLateToPenalize):
        MUTEX.release()
        logReturn(consensusLogReturn, -2)
    if(CONSENSUS.getPenalizedUpTo(branch, msg.sender) == lastPeriod):
        MUTEX.release()
        logReturn(consensusLogReturn, -3)
    if(EVENTS.getForked(event)):
        MUTEX.release()
        logReturn(consensusLogReturn, -4)
    # if no outcome / event not resolved yet, resolve it [as long as it wasn't an event that was pushed fwd and got rejected and thus hasn't actually resolved yet]
    eventNotResolvedAndNeedsToBe = !EVENTS.getOutcome(event) and !(rejected and EVENTS.getRejectedPeriod(event) == lastPeriod)
    if(eventNotResolvedAndNeedsToBe and CLOSEMARKET.closeMarket(EVENTS.getMarket(event, 0), msg.sender) != 1):
        MUTEX.release()
        logReturn(consensusLogReturn, -5)
    if(!CONSENSUS.getRepCollected(branch, msg.sender, lastPeriod - 1)):
        MUTEX.release()
        logReturn(consensusLogReturn, -6)

macro countAsPenalized():
    CONSENSUS.setPenalized(branch, lastPeriod, msg.sender, event)
    CONSENSUS.increasePenalizedNum(branch, lastPeriod, msg.sender, 1)

macro updateAfterRep():
    newAfterRep = EXPEVENTS.getAfterRep(branch, lastPeriod, msg.sender) + repChange
    EXPEVENTS.setAfterRep(branch, lastPeriod, newAfterRep, msg.sender)

def setController(newController: address):
    if(msg.sender != self.controller):
        ~invalid()
    self.controller = newController
    return(1)

def suicideFunds(to: address):
    if(msg.sender != self.controller):
        ~invalid()
    suicide(to)