# Copyright (C) 2015 Forecast Foundation OU, full GPL notice in LICENSE

extern controller: [lookup:[int256]:int256, assertIsWhitelisted:[int256]:int256]

BRANCHES = self.controller.lookup('branches')
extern branches: [addCurrency:[int256,int256,int256,int256]:int256, addMarketToBranch:[int256,int256]:int256, disableCurrency:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranchCurrency:[int256,int256]:int256, getBranchWallet:[int256,int256]:int256, getBranches:[]:int256[], getBranchesStartingAt:[int256]:int256[], getCreationDate:[int256]:int256, getCurrencyActive:[int256,int256]:int256, getCurrencyByContract:[int256,int256]:int256, getCurrencyRate:[int256,int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getForkTime:[int256]:int256, getInitialBalance:[int256,int256,int256]:int256, getMarketIDsInBranch:[int256,int256,int256]:int256[], getMinTradingFee:[int256]:int256, getMostRecentChild:[int256]:int256, getNumBranches:[]:int256, getNumCurrencies:[int256]:int256, getNumMarketsBranch:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256,int256]:int256, reactivateCurrency:[int256,int256]:int256, removeLastCurrency:[int256]:int256, replaceCurrency:[int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setController:[address]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256,int256]:int256, setMostRecentChild:[int256,int256]:int256, suicideFunds:[address]:_, updateCurrencyRate:[int256,int256,int256,int256]:int256, updateNumCurrencies:[int256,int256]:int256]

EXPEVENTS = self.controller.lookup('expiringEvents')
extern expiringEvents: [addEvent:[int256,int256,int256,int256,int256,int256,int256]:int256, addReportToReportsSubmitted:[int256,int256,int256]:int256, addRoundTwo:[int256,int256]:int256, addToWeightOfReport:[int256,int256,int256,int256]:int256, adjustPeriodFeeValue:[int256,int256,int256]:int256, countReportAsSubmitted:[int256,int256,int256,int256,int256]:int256, deleteEvent:[int256,int256,int256]:int256, getActiveReporters:[int256,int256,int256,int256]:int256[], getAfterFork:[int256,int256]:int256, getAfterRep:[int256,int256,int256]:int256, getBeforeRep:[int256,int256,int256]:int256, getCurrentMode:[int256,int256]:int256, getCurrentModeItems:[int256,int256]:int256, getEthicReport:[int256,int256,int256,int256]:int256, getEvent:[int256,int256,int256]:int256, getEventIndex:[int256,int256,int256]:int256, getEventWeight:[int256,int256,int256]:int256, getEvents:[int256,int256]:int256[], getEventsRange:[int256,int256,int256,int256]:int256[], getFeeValue:[int256,int256]:int256, getLesserReportNum:[int256,int256,int256]:int256, getNumActiveReporters:[int256,int256]:int256, getNumEventsToReportOn:[int256,int256]:int256, getNumRemoved:[int256,int256]:int256, getNumReportsSubmitted:[int256,int256,int256]:int256, getNumRequired:[int256,int256]:int256, getNumRoundTwo:[int256,int256]:int256, getNumberEvents:[int256,int256]:int256, getPeriodDormantRep:[int256,int256,int256]:int256, getPeriodRepWeight:[int256,int256,int256]:int256, getReport:[int256,int256,int256,int256]:int256, getRequired:[int256,int256,int256]:int256, getSubsidy:[int256,int256,int256]:int256, getWeightOfReport:[int256,int256,int256]:int256, moveEvent:[int256,int256]:int256, refundCost:[int256,int256,int256,int256]:int256, removeEvent:[int256,int256]:int256, setAfterRep:[int256,int256,int256,int256]:int256, setBeforeRep:[int256,int256,int256,int256]:int256, setController:[address]:int256, setCurrentMode:[int256,int256,int256]:int256, setCurrentModeItems:[int256,int256,int256]:int256, setEthicReport:[int256,int256,int256,int256,int256]:int256, setEventRequired:[int256,int256,int256]:int256, setEventWeight:[int256,int256,int256,int256]:int256, setLesserReportNum:[int256,int256,int256,int256]:int256, setNumEventsToReportOn:[int256]:int256, setPeriodDormantRep:[int256,int256,int256,int256]:int256, setPeriodRepWeight:[int256,int256,int256,int256]:int256, setReport:[int256,int256,int256,int256,int256]:int256, suicideFunds:[address]:_]

CONSENSUS = self.controller.lookup('consensusData')
extern consensusData: [decreaseDenominator:[int256,int256,int256]:int256, doRefund:[int256,int256]:int256, getBaseReportersLastPeriod:[int256]:int256, getDenominator:[int256,int256]:int256, getFeeFirst:[int256,int256]:int256, getFeesCollected:[int256,int256,int256,int256]:int256, getNotEnoughPenalized:[int256,int256,int256]:int256, getPenalized:[int256,int256,int256,int256]:int256, getPenalizedNum:[int256,int256,int256]:int256, getPenalizedUpTo:[int256,int256]:int256, getPeriodBalance:[int256,int256]:int256, getRepCollected:[int256,int256,int256]:int256, getRepRedistributionDone:[int256,int256]:int256, getSlashed:[int256,int256,int256]:int256, increaseDenominator:[int256,int256,int256]:int256, increasePenalizedNum:[int256,int256,int256,int256]:int256, setBaseReportersLastPeriod:[int256,int256]:int256, setController:[address]:int256, setFeeFirst:[int256,int256,int256]:int256, setFeesCollected:[int256,int256,int256,int256]:int256, setNotEnoughPenalized:[int256,int256,int256]:int256, setPenalized:[int256,int256,int256,int256]:int256, setPenalizedUpTo:[int256,int256,int256]:int256, setPeriodBalance:[int256,int256,int256]:int256, setRefund:[int256,int256]:int256, setRepCollected:[int256,int256,int256]:int256, setSlashed:[int256,int256,int256]:int256, suicideFunds:[address]:_]

REPORTING = self.controller.lookup('reporting')
extern reporting: [addDormantRep:[int256,int256,int256]:int256, addRep:[int256,int256,int256]:int256, addReporter:[int256,int256,int256,int256,int256]:int256, adjustActiveRep:[int256,int256]:int256, balanceOfReporter:[int256,int256]:int256, claimInitialRepFromRepContract:[]:int256, getActiveRep:[int256]:int256, getDormantRepByIndex:[int256,int256]:int256, getNumberReporters:[int256]:int256, getRepBalance:[int256,int256]:int256, getRepByIndex:[int256,int256]:int256, getReportedOnNonFinalRoundTwoEvent:[int256,int256]:int256, getReporterID:[int256,int256]:int256, getReputation:[int256]:int256[], getTotalRep:[int256]:int256, repIDToIndex:[int256,int256]:int256, setController:[address]:int256, setInitialReporters:[int256]:int256, setRep:[int256,int256,int256]:int256, setReportedOnNonFinalRoundTwoEvent:[int256,int256,int256]:int256, subtractDormantRep:[int256,int256,int256]:int256, subtractRep:[int256,int256,int256]:int256, suicideFunds:[address]:_, totalSupply:[int256]:int256]

THRESHOLD = self.controller.lookup('reportingThreshold')
extern reportingThreshold: [calculateNumberOfEventsAReporterHasToReportOnAtMinimum:[int256,int256,int256]:int256, calculateReportTargetForEvent:[int256,int256,int256,int256]:int256, calculateReportingThreshold:[int256,int256,int256,int256]:int256, findLazyReportersAndLeechers:[int256,int256,int256,int256,int256,int256]:int256[], getEventCouldveReportedOn:[int256,int256,int256,int256]:int256, getEventsToReportOn:[int256,int256,int256,int256,int256]:int256[], setController:[address]:int256, setReportingThreshold:[int256]:int256, suicideFunds:[address]:_]

EVENTS = self.controller.lookup('events')
extern events: [addMarket:[int256,int256]:int256, addPast24:[int256]:int256, addReportersPaidSoFar:[int256]:int256, getBond:[int256]:int256, getChallenged:[int256]:int256, getCreationTime:[int256]:int256, getEarlyResolutionBond:[int256]:int256, getEthics:[int256]:int256, getEventBranch:[int256]:int256, getEventInfo:[int256]:int256[], getEventPushedUp:[int256]:int256, getEventResolution:[int256]:bytes, getExpiration:[int256]:int256, getExtraBond:[int256]:int256, getExtraBondPoster:[int256]:int256, getFirstPreliminaryOutcome:[int256]:int256, getForkEthicality:[int256]:int256, getForkOutcome:[int256]:int256, getForkResolveAddress:[int256]:int256, getForked:[int256]:int256, getForkedDone:[int256]:int256, getMarket:[int256,int256]:int256, getMarkets:[int256]:int256[], getMaxValue:[int256]:int256, getMinValue:[int256]:int256, getMode:[int256]:int256, getNumMarkets:[int256]:int256, getNumOutcomes:[int256]:int256, getOriginalExpiration:[int256]:int256, getOutcome:[int256]:int256, getPast24:[int256]:int256, getRejected:[int256]:int256, getRejectedPeriod:[int256]:int256, getReportersPaidSoFar:[int256]:int256, getReportingThreshold:[int256]:int256, getResolutionAddress:[int256]:int256, getResolutionLength:[int256]:int256, getResolveBondPoster:[int256]:int256, getUncaughtOutcome:[int256]:int256, initializeEvent:[int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256]:int256, setBond:[int256,int256]:int256, setBranch:[int256,int256]:int256, setChallenged:[int256]:int256, setController:[address]:int256, setCreationTime:[int256]:int256, setEarlyResolutionBond:[int256,int256]:int256, setEthics:[int256,int256]:int256, setEventPushedUp:[int256,int256]:int256, setExpiration:[int256,int256]:int256, setExtraBond:[int256,int256]:int256, setExtraBondPoster:[int256,int256]:int256, setFirstPreliminaryOutcome:[int256,int256]:int256, setForkDone:[int256]:int256, setForkEthicality:[int256,int256]:int256, setForkOutcome:[int256,int256]:int256, setForked:[int256]:int256, setMode:[int256,int256]:int256, setOriginalExpiration:[int256,int256]:int256, setOutcome:[int256,int256]:int256, setRejected:[int256,int256]:int256, setThreshold:[int256,int256]:int256, setUncaughtOutcome:[int256,int256]:int256, suicideFunds:[address]:_]

FXP = self.controller.lookup('fxpFunctions')
extern fxpFunctions: [fxExp:[int256]:int256, fxLog:[int256]:int256, setController:[address]:int256, suicideFunds:[address]:_]

MUTEX = self.controller.lookup('mutex')
extern mutex: [acquire:[]:int256, release:[]:int256, setController:[address]:int256, suicideFunds:[address]:_]

inset('../macros/refund.sem')
inset('../macros/periodStage.sem')
inset('../macros/float.sem')

data controller

macro ONE_POINT_TWO: 1200000000000000000

macro POINT_ZERO_ONE: 10000000000000000

macro POINT_ONE: 100000000000000000

macro POINT_NINE: 900000000000000000

macro MIN_EVENTS_FOR_WHALE: 30

### Allows a user to prove that a reporter didn't report enough / skimped on their reporting requirements

# Prove both that a reporter voted on less than he/she actually could have and it was half of what they should have reported on using an example event that they could've reported on
# The rep lost here is then sent to the branch's rep account and distributed like other redistributed rep.
# Note:
    # Reporters pay an eth bond for this on their first report --- if never called then during collect fees they get it back else it goes back to pay someone who correctly calls this function, so the bond is returned to the poster if not enough penalized is 0
# Returns 1 if successful penalization
# Errors:
    # -1: already done
    # -2: not in right part of period
    # -3: event isn't in branch
    # -4: reported on enough events
def init():
    self.controller = 0x0

def proveReporterDidntReportEnough(branch, reporter, eventExample):
    refund()
    MUTEX.acquire()

    expectedEventsForReporterIncludingRequired = 0
    lastPeriod = BRANCHES.getVotePeriod(branch) - 1
    originalRep = EXPEVENTS.getBeforeRep(branch, lastPeriod, reporter)
    numEventsAvailableToReportOn = EXPEVENTS.getNumEventsToReportOn(branch, lastPeriod)
    # events a user should be reporting on
    # eventsExpected == events available in a period * rep percent**1.2
        # exp(1.2*ln(repbal)) / exp(1.2*ln(totalrep)) is == rep percent**1.2 due to this property: a**b=exp(b*ln(a))=e**(b*ln(a))
    repConstant = safeFxpDiv(FXP.fxExp(safeFxpMul(ONE_POINT_TWO, FXP.fxLog(originalRep))), FXP.fxExp(safeFxpMul(ONE_POINT_TWO, FXP.fxLog(REPORTING.getActiveRep(branch)))))
    numRequiredEvents = EXPEVENTS.getNumRequired(branch, lastPeriod)
    forkPeriod = BRANCHES.getForkPeriod(branch)
    period = BRANCHES.getVotePeriod(branch)
    forkScenario = period == (forkPeriod + 1) or period == (forkPeriod + 2)
    if(forkScenario):
        expectedEventsForReporterIncludingRequired = safeMul(repConstant, numEventsAvailableToReportOn)
    else:
        # include required events in non fork scenarios
        expectedEventsForReporterIncludingRequired = safeMul(repConstant, numEventsAvailableToReportOn) + safeMul(numRequiredEvents, ONE)
    dealWithWhaleReporters()
    ensureReporterCouldveReportedOnMoreButDidnt()
    checkProveReporterDidntReportEnoughPreconditions()
    redistributeNotEnoughReportsRep()
    # refund gas cost for the sender
    CONSENSUS.doRefund(msg.sender, reporter)
    MUTEX.release()
    return(1)

macro checkProveReporterDidntReportEnoughPreconditions():
    if(CONSENSUS.getNotEnoughPenalized(branch, reporter, lastPeriod)):
        MUTEX.release()
        return(-1)
    atFirstHalfOfPeriod()
    if(EVENTS.getEventBranch(eventExample) != branch):
        MUTEX.release()
        return(-3)

macro ensureReporterCouldveReportedOnMoreButDidnt():
    numReportsSubmitted = EXPEVENTS.getNumReportsSubmitted(branch, lastPeriod, reporter)
    # reporter couldve reported on event example but didnt
    couldveReported = THRESHOLD.getEventCouldveReportedOn(branch, lastPeriod, reporter, eventExample)
    reportedOnLessThanShouldve = expectedEventsForReporterIncludingRequired / 2 > safeMul(numReportsSubmitted, ONE) and couldveReported
    if(!reportedOnLessThanShouldve):
        MUTEX.release()
        return(-4)

macro redistributeNotEnoughReportsRep():
    # penalize people
    newRep = safeDiv(safeMul(safeMul(POINT_ONE, numReportsSubmitted), originalRep), (expectedEventsForReporterIncludingRequired / 2))
    oldRep = safeFxpMul(originalRep, POINT_NINE)
    repChange = safeAdd(oldRep, newRep) - originalRep
    if(repChange > 0):
        MUTEX.release()
        return(1)
    repBalance = REPORTING.getRepBalance(branch, reporter)
    if(repBalance + repChange <= 0):
        repChange = -1 * repBalance
    # removes rep from reporter who lost it
    REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, reporter), repChange)
    # sends that rep to the branch rep pool
    REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, branch), -repChange)
    EXPEVENTS.setBeforeRep(branch, lastPeriod, safeAdd(oldRep, newRep), reporter)
    afterRep = EXPEVENTS.getAfterRep(branch, lastPeriod, reporter)
    newAfterRep = safeAdd(afterRep, repChange)
    if(newAfterRep <= 0):
        newAfterRep = 0
    # decrease denominator by rep person lost here if they've already done the penalizations / redistributions in consensus
    if(CONSENSUS.getRepRedistributionDone(branch, reporter)):
        diff = safeSub(afterRep, newAfterRep)
        CONSENSUS.decreaseDenominator(branch, lastPeriod, diff)
    EXPEVENTS.setAfterRep(branch, lastPeriod, newAfterRep, reporter)
    CONSENSUS.setNotEnoughPenalized(branch, reporter, lastPeriod)

macro dealWithWhaleReporters():
    eventsInPeriod = safeSub(EXPEVENTS.getNumberEvents(branch, lastPeriod), EXPEVENTS.getNumRemoved(branch, lastPeriod))
    reporterIsAWhale = repConstant >= POINT_ZERO_ONE
    if(reporterIsAWhale and forkScenario):
        minimum = safeAdd(MIN_EVENTS_FOR_WHALE, numEventsAvailableToReportOn)
        if(expectedEventsForReporterIncludingRequired / ONE < minimum):
            expectedEventsForReporterIncludingRequired = minimum * ONE
    elif(reporterIsAWhale):
        minimum = min(safeAdd(MIN_EVENTS_FOR_WHALE, numRequiredEvents), eventsInPeriod)
        if(expectedEventsForReporterIncludingRequired / ONE < minimum):
            expectedEventsForReporterIncludingRequired = minimum * ONE
    baseReporters = CONSENSUS.getBaseReportersLastPeriod(branch)
    total = safeMul(repConstant, baseReporters)
    # if total is too high [>1] then expectedEventsForReporterIncludingRequired will estimate a higher number than reality, so need to correct for this below
    # correction for if people have more than x [4.6% of at 40 min reporters] rep in one account - they report on everything (hence incentive to divy rep into mult. accounts and not pool) i.e. if((exp(ln(rep%)*1.2)+0.001)*baseReporters > 1)
    if(total > ONE and forkScenario):
        expectedEventsForReporterIncludingRequired = safeMul(safeDiv(numEventsAvailableToReportOn, baseReporters), ONE)
    elif(total > ONE):
        expectedEventsForReporterIncludingRequired = safeAdd(safeMul(safeDiv(numEventsAvailableToReportOn, baseReporters), ONE), safeMul(numRequiredEvents, ONE))

def setController(newController: address):
    if(msg.sender != self.controller):
        ~invalid()
    self.controller = newController
    return(1)

def suicideFunds(to: address):
    if(msg.sender != self.controller):
        ~invalid()
    suicide(to)