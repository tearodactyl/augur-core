# Copyright (C) 2015 Forecast Foundation OU, full GPL notice in LICENSE

inset('../macros/refund.sem')
inset('../macros/safeMath.sem')
inset('../macros/unitConversions.sem')

data controller
data reportingPeriodSeconds
data reportingDisputePeriodSeconds
data reportersPerEvent
# userReports[branch][reportingWindow][reporterAddress]
data userReports[][2**160](reportedEvents[], reportedEventsCount, seed)

extern controller: [lookup:[int256]:int256, checkWhitelist:[int256]:int256]
extern events: [getNumberOfLimitedReporterEvents:[uint256,uint256]:uint256]
extern registrationToken: [totalSupply:[uint256,uint256]:uint256]

def init():
    self.controller = 0x0
    self.reportingPeriodSeconds = 21 * SECONDS_PER_DAY
    self.reportingDisputePeriodSeconds = 3 * SECONDS_PER_DAY
    self.reportsPerEvent = 7

def any():
    refund()

# TODO: simplify this to allow people to report on any event, as long as it doesn't already have too many reporters
# only to be called for events being reported on by a subset of reporters, up to caller to make sure the event is generally elligible for reporting right now
def assertCanReportOnEvent(eventId, reporterAddress):
    # CONSIDER: change this scheme to just disallowing more than `n` reports per event, but allow anyone to report on anything
    branch = self.controller.lookup('events').getEventBranch(eventId)
    currentReportingWindow = self.getCurrentReportingWindow()
    seed = self.getUserSeed(branch, currentReportingWindow, reporterAddress)
    reportsPerReporter = self.getTargetReportsPerReporter(branch, reportingWindow)
    # TODO: run a monte carlo simulation to verify this algorithm is reasonable
    # TODO: figure out a variable name for this that makes sense to readers at a glance
    # TODO: ensure this is tested for pathological cases like prime # of markets & prime # of reporters and 0 events and 1 event
    personallyIndexedEvent = sha3([eventId, seed], items = 2) % totalReporters
    if (personallyIndexedEvent >= reportsPerReporter):
        ~invalid()
    return(1)

# FIXME: if an event moves out of a reporting period (e.g., due to a fork) this may start to return an incorrect result
def assertDoneReporting(branch, reportingWindow, reporterAddress):
    eventsContract = self.controller.lookup('events')
    totalAllReporterEvents = eventsContract.getNumberOfAllReporterEvents(branch, reportingWindow)
    totalLimitedReporterEvents = eventsContract.getNumberOfLimitedReporterEvents(branch, reportingWindow)
    targetReports = self.getTargetReportsPerReporter(branch, reportingWindow)
    # TODO: test this to make sure that a user can't run out of events without reaching target
    if (self.userReports[branch][reportingWindow][reporterAddress] < targetReports):
        ~invalid()
    return(1)

def clearUserReports(branch, reportingWindow, reporterAddress):
    self.controller.checkWhitelist(msg.sender)
    self.userReports[branch][reportingWindow][reporterAddress].reportedEvents = array(0)
    self.userReports[branch][reportingWindow][reporterAddress].reportedEventsCount = 0
    self.userReports[branch][reportingWindow][reporterAddress].seed = 0
    return(1)

def noteUserReport(branch, eventId):
    self.controller.checkWhitelist(msg.sender)
    currentReportingWindow = self.getCurrentReportingWindow()
    startingEventCount = self.userReports[branch][currentReportingWindow][reporterAddress].reportedEventsCount
    self.userReports[branch][currentReportingWindow][reporterAddress].reportedEvents[startingEventCount] = eventId
    self.userReports[branch][currentReportingWindow][reporterAddress].reportedEventsCount = safeAdd(startingEventCount, 1)
    return(1)

def isInReportingPhase():
    startTime = self.getReportingWindowStartTimestamp()
    endTime = startTime + self.reportingPeriodSeconds
    nowIsAfterStartTime = block.timestamp > startTime
    nowIsBeforeEndTime = block.timestamp < endTime
    return(nowIsAfterStartTime && nowIsBeforeEndTime)

def isInReportingDisputePhase():
    startTime = self.getReportingWindowStartTimestamp() + self.reportingPeriodSeconds
    endTime = startTime + self.reportingDisputePeriodSeconds
    nowIsAfterStartTime = block.timestamp > startTime
    nowIsBeforeEndTime = block.timestamp < endTime
    return(nowIsAfterStartTime && nowIsBeforeEndTime)

def getReportingPeriodDurationInSeconds():
    return(self.reportingPeriodSeconds + self.reportingDisputePeriodSeconds)

def getCurrentReportingWindow():
    return(self.getReportingWindowForTimestamp(block.timestamp))

def getReportingWindowForTimestamp(timestamp):
    return(timestamp / self.getReportingPeriodDurationInSeconds())

def getCurrentReportingWindowStartTimestamp():
    return(self.getCurrentReportingWindow() * self.getReportingPeriodDurationInSeconds())

def getCurrentReportingWindowEndTimestamp():
    return(self.getReportingWindowStartTimestamp() + self.getReportingPeriodDurationInSeconds())

def getTargetReportsPerReporter(branch, reportingWindow):
    numberOfLimitedReporterEvents = self.controller.lookup('events').getNumberOfLimitedReporterEvents(branch, reportingWindow)
    numberOfAllReporterEvents = self.controller.lookup('events').getNumberOfAllReporterEvents(branch, reportingWindow)
    totalReporters = self.controller.lookup('registrationToken').totalSupply(branch, reportingWindow)
    totalLimitedReporterReports = safeMul(numberOfLimitedReporterEvents, self.reportsPerEvent)
    reportsPerReporter = safeAdd(safeDiv(totalLimitedReporterReports, totalReporters), numberOfAllReporterEvents)
    return(reportsPerReporter)

def getUserSeed(branch, reportingWindow, reporterAddress):
    seed = self.userReports[branch][reportingWindow][reporterAddress].seed
    if (seed == 0):
        seed = sha3([reporterAddress, block.prevhash], items = 2)
        self.userReports[branch][reportingWindow][reporterAddress].seed = seed
    return(seed)
